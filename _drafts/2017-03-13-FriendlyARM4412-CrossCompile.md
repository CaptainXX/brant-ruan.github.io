---
title: FriendlyARM-4412 交叉编译环境搭建及编译
category: CS
---

## FriendlyARM-4412 交叉编译环境搭建及编译

### 何为交叉编译？

一言蔽之，就是在当前平台（ CPU 架构和 OS ）环境下编译出另一个平台上的可执行程序，常用于嵌入式。为什么不在目标平台上直接编译？因为有各种各样的麻烦。更多内容可以参考【参考资料】第二个链接。

### 基本参数

交叉编译目标平台： FriendlyARM-4412

交叉编译宿主平台： Ubuntu 14.04 LTS x64 Intel

交叉编译基本任务：

- Bootloader
- Linux kernel
- Android kernel

### 编译环境搭建

在开发板光盘镜像资源中找到`DiskA/Linux/arm-linux-gcc-4.5.1-v6-vfp-20120301.tgz`，复制到`Ubuntu`下合适的目录解压，然后为了方便在`PATH`环境变量中加入`arm-linux-gcc`的路径，下面以我的为例：

```
vim ~/.bashrc
# 在最后面加上下面的语句，注意一定要写绝对路径
export PATH=$PATH:/home/brant-ruan/NewBeginning/CrossCompileEnv/ARM-GCC/opt/FriendlyARM/toolschain/4.5.1/bin
```

#### 兼容问题

64 位 Ubuntu 运行 32 位程序需要安装相关`lib`，否则运行`arm-linux-gcc`时可能出错，安装下面三个包即可：

```
sudo apt-get install lib32z1
sudo apt-get install lib32ncurses5
sudo apt-get install lib32bz2-1.0
```

#### 测试

与正常使用`gcc`方法相同，写一个简单的`Helloworld`程序，使用`arm-linux-gcc`编译成功即可。

### 编译 Bootloader

#### 什么是 Bootloader?

嵌入式设备中一般并没有`BIOS`这样的东西，所以`Bootloader`就起到类似于`BIOS`在`PC`上的作用：初始化硬件设备，引导操作系统内核的加载。

一个嵌入式 Linux 系统从软件角度看可以分为四个层次：

- 引导加载程序（ firmware + bootloader ）
- Linux kernel
- Filesystem
- 应用程序

常见的`bootloader`：

```
Redboot Redhat 公司开源
U-Boot 由开源项目 PPCBoot 发展而来
```

我们使用`U-Boot`作为`bootloader`。

#### 编译 U-Boot 源码

在开发板光盘镜像资源中找到`DiskA/uboot`目录下的源码压缩包和编译说明。解压源码后按照编译说明进行编译：

- 配置 U-Boot 并编译

```
cd uboot_tiny4412
make tiny4412_config
make
```

命令简单解释：第二条命令指定为`tiny4412`开发板生成`.boards.depend`文件，`boards.cfg`中列出了不同开发板型号的平台相关信息。

- 编译用于生成`bl2`的工具

```
make -C sd_fuse
```

**什么是`bl2`？**

我们知道，`bootloader`的平台相关性很强。从开发板资源中`uboot`的 ReadMe 中发现，该`uboot`源码由三星原厂提供，由 FriendlyARM 修改移植。【参考资料】第四个显示，`bl2`即`bootloader2`，属于三星开发板引导的一部分。三星开发板的引导分为三个部分：`bl0`/`bl1`/`bl2`,如下图：

![]({{ site.url }}/resources/pictures/S5PV210.png)

`bl0`即`iROM`，做初始化并把`bl1`加载到`SRAM`；  
`bl1`将加载剩下的`bootloader`，即`bl2`到`SRAM`；  
`bl2`将初始化`DRAM控制器`并将`OS`加载到`SDRAM`。

**开发板附带的光盘镜像中的`uboot`源码有坑！新板子需要新的`uboot`源码，使用旧源码会导致烧入SD卡装入开发板开始串口调试时仅仅显示`OK`，无法与之交互。感谢【参考资料】第六个文章的博主！**

#### U-Boot 源码简要分析及版本修改

**源码分析留坑吧，暂时不填了。**

修改显示的版本的事情比较简单。参考[官方的 FTP 目录](ftp://ftp.denx.de/pub/u-boot/)可以发现， 2008 年 10 月以前，压缩包都按照版本号命名，之后开始按照年月的格式命名。

**但是在哪里设定版本号呢？下面就是有(zuo)趣(si)的溯源之旅 :)**

首先我们要准备好大杀器：

```
grep -rn "WANTED-STRING" ./*
```

上面这个命令可以帮助我们在庞杂的文件群中定位字符串。

开始。

我们优雅地使用百度，发现有两处提到版本号的地方：

- Makefile 的前几行
- 源码中 setenv(ubootversion,XXXXXXXXXXXXX) 设置环境变量

Makefile 前几行确实有一些东西：

```
VERSION = 2010
PATCHLEVEL = 12
SUBLEVEL =
EXTRAVERSION =
ifneq "$(SUBLEVEL)" ""
U_BOOT_VERSION = $(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
else
U_BOOT_VERSION = $(VERSION).$(PATCHLEVEL)$(EXTRAVERSION)
endif
TIMESTAMP_FILE = $(obj)include/timestamp_autogenerated.h
VERSION_FILE = $(obj)include/version_autogenerated.h
```

实验表明，在这里把`VERSION`和`PATCHLEVEL`变量改掉确实可以达到修改最终版本信息的目的。但是`setenv`又是什么呢？它和`Makefile`里的版本信息有什么关系呢？

我们`grep -rn "setenv" ./* | grep 'version'`发现：

```
./common/main.c:333:
setenv ("ver", version_string);  /* set version variable */
```

从【参考资料】第五个我们得知`main.c`是与平台无关的代码，`U-Boot`程序的入口在这里。其中有一个`main_loop()`函数，其中的一段代码用来设置版本号：

```
#ifdef CONFIG_VERSION_VARIABLE
    {
        extern char version_string[];
        setenv ("ver", version_string);  /* set version variable */
    }
#endif /* CONFIG_VERSION_VARIABLE */
```

也就是说，真正影响我们在进行串口调试时看到内容的代码是这些。那么，修改这里理论上来说也是可以改变版本号的（未尝试）。但是，`version_string`又是什么？

继续使用大杀器。我们在`./arch/arm/lib/board.c`中找到了：

```
const char version_string[] =
    U_BOOT_VERSION" (" U_BOOT_DATE " - " U_BOOT_TIME ")"CONFIG_IDENT_STRING;
```

所以`U_BOOT_VERSION`又是什么？继续搜索我们发现，有一个宏定义：

```
./include/version_autogenerated.h:1:
#define U_BOOT_VERSION "U-Boot 2010.12"
```

然而在进行`make`之前，`./include/version_autogenerated.h`文件是不存在的，回到我们之前研究的`Makefile`，它有一个下面的变量：

```
VERSION_FILE = $(obj)include/version_autogenerated.h
```

对这个变量有以下操作：

```
$(VERSION_FILE):
        @( printf '#define U_BOOT_VERSION "U-Boot %s%s"\n' "$(U_BOOT_VERSION)" \
         '$(shell $(TOPDIR)/tools/setlocalversion $(TOPDIR))' ) > $@.tmp
        @cmp -s $@ $@.tmp && rm -f $@.tmp || mv -f $@.tmp $@
```

至此，我们找到了从`Makefile`中变量到头文件再到`main.c`的版本号传递过程。

下面是修改版本成为`Hello,world0.0`的结果（通过在`Makefile`里修改实现）：

![uboot-version]({{ site.url }}/resources/pictures/uboot-version.png)

#### 烧录方法

首先要有一张 4G 以上的 SD 卡。请先备份卡上重要文件。如果上面已经有分区，删除掉：

```
sudo fdisk -l # 查看 SD 卡的设备名，这里是 /dev/sdb
sudo fdisk /dev/sdb
输入 p 查看分区
输入 d 删除分区
```

接着进入`sd_fuse/tiny4412`目录，

```
sudo ./sd_fusing.sh /dev/sdb
```

然后等待就可以了。

#### 串口调试

我们使用 Linux 下的串口通信工具`minicom`来进行串口调试。（关于`minicom`的用法自行搜索吧，很简单的）

```
# install minicom
sudo apt-get install minicom
```

安装完成后首先要配置一下,`minicom -s`进入配置界面，选择`Serial port setup`，接着分别将相应参数设置为下面的：

```
Serial Device         : /dev/ttyUSB0
Bps/Par/Bits          : 115200 8N1
Hardware Flow Control : No
```

接着就是把 SD 卡插到开发板上，把 S2 拨到 SDBOOT 处，使用串口线和 USB 转接线把板子和电脑连起来。再在电脑命令行中启动`minicom`，接着将开发板插电并打开开关，此时就可以看到`U-BOOT`的启动提示，正是我们上一张图片展示的那样。

相关按钮，开关等的位置，请参考开发板附带的`Tiny4412用户手册.pdf`。

### 编译 Linux kernel

我们使用`linux-3.0.86`版本的内核。参照`Tiny4412用户手册.pdf`进行编译：

进入源码文件夹，

```
cp tiny4412_android_defconfig .config
make
```

最后会在`arch/arm/boot`下生成`zImage`，它就是我们要的。

注：正常来说，编译 Linux 内核，我们往往是自己进行`make menuconfig`来选择模块选择以及配置等选项，然后再`make`，这里由于用的是`FriendlyARM`的板子，所以直接把它给的配置文件拷贝成`.config`，省去了自己配置的步骤。

**后来所有东西都编译完成，进行烧录测试时，发现`minicom`卡在`Uncompressing Linux... done, booting the kernel.`这里。在【参考资料】第九个中得知`uboot`不支持内核的`trustzone`，所以在这里要通过`make menuconfig`把`trustzone`的编译选项去掉。否则无法正常开机。**

#### 修改 Linux kernel 源码版本号

又是一个修改版本号的地方。搞到这里，我一直在思考老师让我们修改版本号的目的。是为了证明这个镜像是自己编译出来的而不是从其他同学那里拷到的？还是希望我们借着学习修改版本号做的研究去了解一下源码的结构，或者读一读源码？总之，单纯修改版本号没什么大的意义，意义在于学习和探究本身。

说说版本号吧。同样，也是`Makefile`的前几行中的变量指定了版本号，所以我们可以修改这里。例如，我们把`EXTRAVERSION`赋值为`1111111`（默认是空的）。

### 编译 Android kernel

我们使用`android-5.0.2`版本的源码。参照`Tiny4412用户手册.pdf`进行编译：

由于源码包及编译结果所占空间过大，我选择放在移动硬盘上进行编译。这里遇到一个问题，即`NTFS`格式的移动硬盘挂载到我的`Ubuntu`上是不具有可执行权限的，即使`root`身份进行`chmod`也没用。这时候要手动挂载：

```
umount /dev/sdb1 # 先卸载
# rw 代表读写， exc 代表可执行
mount -0 rw,exc /dev/sdb1 /media/brant-ruan/temp
```

之后即可进行编译。在源码文件夹下（注意要以`root`权限操作，否则可能失败）：

```
. setenv
make -j4 # 4 核编译加快速度
```

编译过程可能会因为当前系统缺少各种依赖包而停止，如果停止，你需要看一下命令行输出的信息显示你缺少什么包，然后`apt-get install`。当然，也可以预先参考 Google 给出的依赖包统一安装，然后再编译。编译耗时很长，而且与机器性能有很大关系。我这里总共编译了 12 个小时。

编译成功后，执行`./gen-img.sh`生成镜像文件`system.img`和`ramdisk-u.img`，它俩就是我们要的。在执行上面脚本的过程中如果缺少对应软件包则会提示，按照提示安装即可，然后再重新执行。

#### 修改 Android 源码版本号

Android 的版本号则存在于`/build/core/version_defaults.mk`的`PLATFORM_VERSION`变量。所以修改这里就可以了。

### Linux kernel 与 Android 的烧录测试

我们先把之前生成的三个东西：`zImage`/`ramdisk-u.img`/`system.img`放到一个目录，这里假设是`./temp`中，方便后面的使用。

参考开发板附带的`readme`：

进行到此，我们已经完成：

- U-Boot 的编译与烧录
- Linux kernel 的编译
- Android 5.0.2 的编译

下面开始：

以`root`身份进行串口调试，进入`minicom`，执行以下操作：

- 分区

```
fdisk -c 0 800 800 800
```

这里要说明一下，`readme`中写的是分成`320 806 518`，但是似乎会导致空间不足，所以我索性分得大一些。

- 格式化分区

```
fatformat mmc 0:1
```

- 进入 fastboot 烧写 Android

这里首先需要另外用 USB 数据线连接板子的`MICRO_USB`口到电脑（也就是说，此时开发板一方面通过串口转 USB 连接，一方面通过 USB 连接，共两个连接）。然后在当前`minicom`窗口中输入`fastboot`。

- 烧写 Android 到 SD 卡的准备工作

接着，重新打开一个`root`身份的窗口。接下来要在当前`bash`中使用`fastboot`工具，如果你没有，系统会提醒你安装。但是似乎`Ubuntu 14.04`自带的软件包中的`fastboot`版本有些旧，会导致后面在烧写时产生一个`data too large`的报错。至少我这里报错了。我们使用 Google 官方提供的新`fastboot`，从[这里](https://dl.google.com/android/repository/platform-tools-latest-linux.zip)下载。

- 烧写 Linux kernel

使用上一步准备好的`fastboot`，进入`./temp`,输入

```
../mytools/fastboot flash kernel ./zImage
```

- 格式化 userdata 和 cache

```
../mytools/fastboot -w
```

- 烧写 ramdisk

```
../mytools/fastboot flash ramdisk ./ramdisk-u.img
```

- 烧写 system

之前我们说到的旧版本`fastboot`可能导致的问题就出在这里。`readme`中说要用`fastboot flash system system.img`烧录，然而我这里总是失败，搜索了一下发现是因为`fastboot`默认定义了最大`img`文件是`120M`,所以我们需要指定一下镜像是超出它的要求的，经测试，下面的语句有效：

```
../mytools/fastboot flash -S 256M system system.img
```

**刚刚从【参考资料】第十个得知，原来 Android 编译完成后在`out/host/linux_x86/bin`下就有`fastboot`，最好用这个。Orz，好吧好吧。下次知道了。**

- 重启

如果在之前编译 Linux kernel 时去掉了`trustzone`选项，这时应该可以正常启动并进入桌面。

- 然而，存在问题

开机后，过一会儿如果你不碰触屏，它就会变花屏，并且无法控制。同学测试发现如果使用`superboot`代替`uboot`作为`bootloader`则不会出现这个问题，前面也不必在编译时去掉`trustzone`。所以，后面讲一下使用`superboot`吧。

花屏时的症状：

![error-screen]({{ site.url }}/resources/pictures/error-screen.png)

**有一个思路，找到显示屏的驱动，在编译 Linux 内核时加入对该驱动的调试信息输出，也许能够找到问题所在，留坑先。**

### 使用 superboot 作为 bootloader 编译及烧录测试

鉴于前边所述的花屏问题，这里进行`superboot`引导测试。

#### 烧写`superboot`

参照`Tiny4412用户手册.pdf`，后续工作都在 Window 7 上进行。

把 SD 卡通过读卡器插到电脑上。  
使用光盘中提供的工具`SD-Flasher`，右键以管理员模式运行。打开后选择`Tiny4412`。  
选择`ReLayout`分割 SD 卡。完成后点击`Scan`发现 SD 卡已经变成`Available`。  
在界面上方选择要烧写的`superboot.bin`（来自光盘资源），注意不要放在中文路径下。  
点击`Fuse`。  

#### 烧写系统

在上一步已经做好的基础上，在 SD 卡中相继建立`images/Android`目录，从光盘中拷贝`FriendlyARM.ini`放入`images`下，将刚刚的`superboot.bin`放在`images`下，将我们编译好的`zImage`/`system.img`/`ramdisk-u.img`放入`images/Android`下（注意，这是新版的`superboot`，需要依赖内核的`trustzone`，所以之前编译内核时不能把该选项去掉）。之后再把`Android-userdata-4g.img`/`userdata-8g.img`/`userdata-16g.img`/`userdata.img`放入`images/Android`下。编辑`FriendlyARM.ini`，将除了`Android 5`外的其他引导删掉（因为我们这里只有`Android 5`）。

到此，SD 卡上至少有下列文件：

- images\Superboot4412.bin
- images\Android\zImage
- images\Android\ramdisk-u.img
- images\Android\system.img
- image\Android\userdata.img
- images\FriendlyARM.ini

之后吧 SD 卡取下，插到开发板上，拨动开关选择`SDBOOT`，加电。之后会进行烧写。成功后屏幕上有相应提示。这时把开关拨动到另一头，重新打开开发板，能够正常进入`Android`系统。

最终效果如下：

![bingo]({{ site.url }}/resources/pictures/bingo.jpg)

### 结语

“只在此山中，云深不知处”（简单点，操作的方式简单点。。。）。嵌入式很有意思，路漫漫，吾将上下求索。

### 参考资料

1. [ubuntu14.4下安装4412交叉编译器](http://blog.csdn.net/u012075739/article/details/40344719)
2. [Introduction to cross-compiling for Linux](http://landley.net/writing/docs/cross-compiling.html)
3. [百度百科：BootLoader](http://baike.baidu.com/link?url=GL3A2Ll4iNqI9hCxMDRqP0Q4qqvqyCuW_k1M1daibMCZKOw2mWjtQo4-Fp-uUjwsEYGHnGZWlxCulKqdAh7Uc_q8rhJLb1ztL-mjgvpHigy)
4. S5PV210_iROM_ApplicationNote_Preliminary_20091126.pdf
5. [【嵌入式】探究bootloader,分析u-boot源码](http://liucw.blog.51cto.com/6751239/1202976)
6. [Tiny4412标准版，编译u-boot并烧录到SD卡，从SD卡启动后只打印‘OK’两个字符](http://blog.csdn.net/u010245383/article/details/50946170)
7. [手把手教你从头开始搭建友善之臂ARM-tiny4412开发环境（史上最详细!!）](http://blog.csdn.net/morixinguan/article/details/50677105)
8. Tiny4412用户手册
9. [Tiny4412的Android系统启动问题](http://www.arm9home.net/read.php?tid-83183.html)
10. [fastboot烧写system提示data too large错误](http://blog.csdn.net/mike8825/article/details/53360416)