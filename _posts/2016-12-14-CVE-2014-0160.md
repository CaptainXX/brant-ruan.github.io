---
title: CVE-2014-0160
---

## 百足之虫，死而不僵

**——基于 ZoomEye 大数据探索 Heartbleed （心脏滴血漏洞）**

### Heartbleed 简介

#### 基本信息

CVE 编号：CVE-2014-0160

曝光时间： 2014 年 4 月 7 日

危害等级：严重

相关软件受影响版本： OpenSSL 1.0.1~1.0.1f

*注： SSL/TLS 协议本身不存在这个漏洞*

主要危害：服务器内存数据泄露（以每次最多 64KB 的速度），进而导致密钥或其他敏感信息泄露。由于 OpenSSL 广泛用于包括金融在内的各个行业，所以危害之大之广，前所未有

原因简述： OpenSSL 在实现 TLS/DTLS 心跳扩展协议 (RFC6520) 时没有检查客户端载荷与载荷长度值是否匹配

修复措施：使用最新版本的 OpenSSL

#### 原理分析

以下分析基于 OpenSSL 1.0.1f 源代码进行。另外， TLS 本身不支持上层的 UDP 协议，所以有了扩展协议 DTLS 。 DTLS 和 TLS 在实现 heartbeat 部分的代码基本相同，这里基于 DTLS 代码讨论， TLS 相关代码可以在 `/ssl/t1_lib.c` 中找到。

典型的 SSL/TLS 会话建立过程是，客户端和服务端进行握手，协商加密算法，参数；成功后，进行加密通信，此时也开始心跳包的发送和接收，用于判断对方是否在线。问题出在服务端对心跳包的处理逻辑上。

心跳包特点：当接受者收到心跳包 A 时，要回复给发送者一个心跳包 B ，B 的载荷要与 A 的相同。发送者收到 B ，将之与 A 比对，相同，则连接有效；不同，则重传该心跳包。

和 Heartbeat 相关的代码有 Request 和 Response 两处，均位于 `/ssl/d1_both.c` 中：

Request 是 `int dtls1_heartbeat(SSL *s)` ； Response 是 `int dtls1_process_heartbeat(SSL *s)` （两函数的完整代码见附录）。

参照 `int dtls1_heartbeat(SSL *s)` 可以发现心跳包请求的格式如下：

```
     *  - Message Type, 1 byte
     *  - Payload Length, 2 bytes (unsigned int)
     *  - Payload, the sequence number (2 bytes uint)
     *  - Payload, random bytes (16 bytes uint)
     *  - Padding
```

心跳包请求部分的代码逻辑没有问题，但是要注意一点，凡是客户端发出的，都是可以伪造的。客户端对载荷和填充位的总大小做了限制：

```
    /* Check if padding is too long, payload and padding
     * must not exceed 2^14 - 3 = 16381 bytes in total.
     */
```

但是我们完全可以自己按照上面的格式构造请求并发包，载荷长度的定义是两字节，所以我们能够把载荷长度设定为 65535 。

参照 `int dtls1_process_heartbeat(SSL *s)` 可以发现处理心跳包请求的逻辑如下：

先用指针 p 指向 收到的心跳请求首地址：

{% highlight c %}
    unsigned char *p = &s->s3->rrec.data[0], *pl;
    unsigned short hbtype;
    unsigned int payload;
    unsigned int padding = 16; /* Use minimum padding */
{% endhighlight %}

分别用 hbtype, payload 取出心跳包类型，客户端设定的载荷长度，并用 pl 指向载荷内容的首地址：

{% highlight c %}
    hbtype = *p++;
    n2s(p, payload);
    pl = p;
{% endhighlight %}

判断，如果心跳包类型是请求，就分配空间，分配大小为 1 字节（心跳包类型）， 2 字节（载荷长度）， payload 字节（填充载荷）， padding 字节（填充字节， 定义为 16 ）：

{% highlight c %}
    if (hbtype == TLS1_HB_REQUEST)
        {
        unsigned char *buffer, *bp;
        int r;
        /* Allocate memory for the response, size is 1 byte
         * message type, plus 2 bytes payload length, plus
         * payload, plus padding
         */
        buffer = OPENSSL_malloc(1 + 2 + payload + padding);
        bp = buffer;
{% endhighlight %}

之后就是构造返回包：

{% highlight c %}
        /* Enter response type, length and copy payload */
        *bp++ = TLS1_HB_RESPONSE;
        s2n(payload, bp);
        memcpy(bp, pl, payload);
        bp += payload;
        /* Random padding */
        RAND_pseudo_bytes(bp, padding);
{% endhighlight %}

注意上面代码中的 `memcpy(bp, pl, payload);` ，复制的长度是 payload ，这个值是客户端决定的，服务端没有检查。一旦我们构造一个恶意的请求包，设定的长度为 payload ，但我们发送的实际载荷比 payload 短，或者根本不发送载荷，那么这个 `memcpy` 将把服务端内存中的其他数据复制到 `buffer` 中，并返回给发送方！这就是问题所在。

最极端的情况下，攻击者可以总设定载荷长度为 65535(64KB) ， 但不发送任何载荷，这样服务端内存数据将以每次 64 KB 的速度泄露。攻击者可以多次发送这样的心跳请求，而内存泄露的地方是随机的。

### 大数据分析

**以下数据及分析主要来自知道创宇 ZoomEye 。感谢知道创宇。另外，他们也让我们认识到数据可视化的重要性。**

**在真正的网络战打响之前，去评估各国的网络战能力是困难的。真实战争可以通过武器、作战人数、战略资源等去评估国家的作战能力，而网络战是无形且隐蔽的，我们很难去评估各个国家网络战时的攻击和防御能力。**

**此次的“心脏出血”漏洞，全球影响范围广，影响目标重要，影响危害大，且在技术上容易检测，为我们比较各个国家的网络战能力提供了一次非常难得的机会。**

#### 曝光初期数据统计分析

**我们使用大数据，是为了从数据中提取有价值的深层次信息。**

**通过漏洞曝光第一天的影响范围，可以看出世界各国的信息化建设情况。**

ZoomEye 团队探测的数据显示，第一天全球网络空间受影响的网络设备数量为 2,433,550 。漏洞影响态势如下图，颜色越深代表该国受影响的网络设备数量越多。

![]({{ site.url }}/images/heartbleed/0day-01.png)

很明显，美国颜色最深，非洲中部和朝鲜都是白色。对于非洲来说，这反映了它们的信息化水平可能不是很高；由于朝鲜国家网络没有接入因特网，所以无法从这张图看出朝鲜信息化水平。

下面这张图是受影响国家/地区 Top 25 ：

![]({{ site.url }}/images/heartbleed/0day-02.png)

通过统计对比，美国受漏洞影响的网络设备数量约占全球 34% 左右，而受该漏洞影响的网络设备均为重要信息系统，因此也反映出美国重要信息系统的建设能力处于全球领先地位。

反观中国受漏洞影响的数量占比不足全球的 1.5% ，远低于美国，说明国内重要信息系统建设不够发达，与中国的国际地位严重不符，我国仍需要大力发展信息网络时代的基础建设。

**通过漏洞曝光后短时间内的修复状况，可以看出各个国家面对此次严重漏洞时的反应能力，也侧面反映了各个国家在网络战时的防御能力。**

![]({{ site.url }}/images/heartbleed/0day-03.png)

从图可以看出，第一天和第三天的漏洞影响数量进行比较，全球的漏洞修复率为 40% ；新加坡的漏洞修复率最高，达到 57% ；美国的漏洞修复率仅次之，为 49% ，排名第二；而中国的修复率为 18% ，低于全球平均水平，全球排名仅 102 位。

**一言蔽之，我国的信息化能力与大国地位还差的很远。诸位，我们任重而道远。**

#### 曝光一周年数据统计分析

经过一年的攻防对抗，在“心脏出血”漏洞爆发一周年之际， ZoomEye 团队对它进行了一次回归性普查扫描。受影响 IP 数量为 377,221 。

地理分布如下图：

![]({{ site.url }}/images/heartbleed/1year-01.png)


一周年持续响应速度统计如下：

![]({{ site.url }}/images/heartbleed/1year-02.png)

受影响协议饼状比例分布：

![]({{ site.url }}/images/heartbleed/1year-03.png)

可以看出 HTTPS 占比超过 0.5 ，这也反映出 Web 的流行。

经过一周年前后，新旧数据对比分析，可以得到如下启示：

- 全球修复效率较高，一年的时间，全球受影响IP数量仅为爆发时的 14.6%
- 协议依赖性明显，受影响 IP 中， HTTPS(443) 两次占比都超过 50%
- 西方发达国家修复效率高于发展中国家，从前后两次“受影响国家/地区 TOP25 ”来看，由于西方发达国家 IP 资源比较丰富（如美国 IP 地址就占全球近 1/3 ），所以 14 年统计的 TOP25 ，较多来自西方发达国家；而经过一年的持续性修复，可以看到， 15 年统计的 TOP25 ，出现了较多的发展中国家（如中国、巴西、俄罗斯、印度等）
- 较大规模站点对安全更为重视，通过抽样检测， FaceBook 、 Yahoo！ 、淘宝、支付宝、京东等国内外知名网站未发现相关漏洞
- 我国持续响应能力依然需要努力提高，虽然从最初的 18% 的修复率，上升到了 59.9% ，但是对比于韩国（69.5%）、俄罗斯（78.0%）、香港（81.8%）、台湾（95.6%）以及日本（99.0%），网络空间的安全防御能力依然令人担忧

### 实践：2016年末对 THA 的漏洞探查及统计分析

如今距 Heartbleed 的曝光已经过去两年半，互联网上的漏洞存在情况如何？

通过实践，我得出了结论，也是本文的标题——百足之虫，死而不僵。

**注明：**

**本文涉及到的技术和方法仅供学习研究使用，请遵守《中华人民共和国网络安全法》。请勿对目标主机造成干扰和损害。**

漏洞探查思路：

- 借助 ZoomEye API 编写程序获得一批使用了 OpenSSL 的目标 IP
- 使用扫描程序，配合批处理，进行批量扫描

由于我只有一台普通计算机，所以对目标做下列限制：

- 仅仅探测 HTTPS 协议（ 443 端口）
- 目标地区限定在 THA ，这主要有下面几点考虑：
	- THA 在上面的统计分析中没有出现，扫描 THA 也是对以上数据的补充
	- 基于个人电脑性能，对修复率过高的国家扫描可能很久也扫不到一个漏洞

下面介绍具体的探测过程：

#### 使用 ZoomEye 批量获取开放 443 端口的主机 IP

修改页数参数，多次执行下面程序：

![]({{ site.url }}/images/heartbleed/2year-03.png)

#### Heartbleed 检测

采用 CVE-2014-0160 by Jared Stafford 程序进行漏洞检测。该程序可以通过网络获得，不再列出（在后面的叙述中以 scan.py 为其名）。它的逻辑非常简单：先发送握手包，与服务端握手，再发送畸形心跳包，等待返回数据。畸形心跳包如下：

{% highlight python %}
hb = [
"18"      # Content Type: Heartbeat (24) ---- (0x18)
"03 02"   # Version: TLS 1.1 (0x0302)
"00 03"   # Heartbeat Message:
"01"      #    Type: Request (1) (0x01)
"40 00"   #    Payload Length: (16384) (0x4000)
]
{% endhighlight %}

通过

{% highlight python %}
import os

f = open("remain.txt", "r")
i = 0
for line in f.readlines():
    print("echo " + line[:-1] + " >> result.txt")
    print("python scan.py " + line[:-1] + " >> result.txt")
    i = i + 1
f.close()
{% endhighlight %}

形成批处理程序进行批量测试。

#### 结果展示

被探测的 IP 数量： 5218

存在 Heartbleed 漏洞的 IP 数量： 62

漏洞存在率： 1.188%

存在漏洞的 IP 地址如下（末几位已打码）：

![]({{ site.url }}/images/heartbleed/2year-01.png)

虽然我们仅仅进行测试，但还是可以看到一些有意思的东西：

![]({{ site.url }}/images/heartbleed/2year-02.png)

### 总结

借助大数据，我们可以实时掌握漏洞的各种信息，并能够从侧面了解到不同国家和地区的网络实力。同时，我们也得出一个结论：百足之虫，死而不僵。事实上，世界上的计算机数量太过庞大，不仅仅是 Heartbleed ， 大多数表面上已经过时的漏洞依然存在于某些角落。网络安全最让人担心的就是“短板效应”，只有每次漏洞曝光时都积极响应，并持续跟进，才能把发生大规模危害的概率降到最低。

### 附录

#### int dtls1_heartbeat(SSL *s)

{% highlight c %}
int
dtls1_heartbeat(SSL *s)
	{
	unsigned char *buf, *p;
	int ret;
	unsigned int payload = 18; /* Sequence number + random bytes */
	unsigned int padding = 16; /* Use minimum padding */

	/* Only send if peer supports and accepts HB requests... */
	if (!(s->tlsext_heartbeat & SSL_TLSEXT_HB_ENABLED) ||
	    s->tlsext_heartbeat & SSL_TLSEXT_HB_DONT_SEND_REQUESTS)
		{
		SSLerr(SSL_F_DTLS1_HEARTBEAT,SSL_R_TLS_HEARTBEAT_PEER_DOESNT_ACCEPT);
		return -1;
		}

	/* ...and there is none in flight yet... */
	if (s->tlsext_hb_pending)
		{
		SSLerr(SSL_F_DTLS1_HEARTBEAT,SSL_R_TLS_HEARTBEAT_PENDING);
		return -1;
		}

	/* ...and no handshake in progress. */
	if (SSL_in_init(s) || s->in_handshake)
		{
		SSLerr(SSL_F_DTLS1_HEARTBEAT,SSL_R_UNEXPECTED_MESSAGE);
		return -1;
		}

	/* Check if padding is too long, payload and padding
	 * must not exceed 2^14 - 3 = 16381 bytes in total.
	 */
	OPENSSL_assert(payload + padding <= 16381);

	/* Create HeartBeat message, we just use a sequence number
	 * as payload to distuingish different messages and add
	 * some random stuff.
	 *  - Message Type, 1 byte
	 *  - Payload Length, 2 bytes (unsigned int)
	 *  - Payload, the sequence number (2 bytes uint)
	 *  - Payload, random bytes (16 bytes uint)
	 *  - Padding
	 */
	buf = OPENSSL_malloc(1 + 2 + payload + padding);
	p = buf;
	/* Message Type */
	*p++ = TLS1_HB_REQUEST;
	/* Payload length (18 bytes here) */
	s2n(payload, p);
	/* Sequence number */
	s2n(s->tlsext_hb_seq, p);
	/* 16 random bytes */
	RAND_pseudo_bytes(p, 16);
	p += 16;
	/* Random padding */
	RAND_pseudo_bytes(p, padding);

	ret = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buf, 3 + payload + padding);
	if (ret >= 0)
		{
		if (s->msg_callback)
			s->msg_callback(1, s->version, TLS1_RT_HEARTBEAT,
				buf, 3 + payload + padding,
				s, s->msg_callback_arg);

		dtls1_start_timer(s);
		s->tlsext_hb_pending = 1;
		}

	OPENSSL_free(buf);

	return ret;
	}
{% endhighlight %}

#### int dtls1_process_heartbeat(SSL *s)

{% highlight c %}
int
dtls1_process_heartbeat(SSL *s)
	{
	unsigned char *p = &s->s3->rrec.data[0], *pl;
	unsigned short hbtype;
	unsigned int payload;
	unsigned int padding = 16; /* Use minimum padding */

	/* Read type and payload length first */
	hbtype = *p++;
	n2s(p, payload);
	pl = p;

	if (s->msg_callback)
		s->msg_callback(0, s->version, TLS1_RT_HEARTBEAT,
			&s->s3->rrec.data[0], s->s3->rrec.length,
			s, s->msg_callback_arg);

	if (hbtype == TLS1_HB_REQUEST)
		{
		unsigned char *buffer, *bp;
		int r;

		/* Allocate memory for the response, size is 1 byte
		 * message type, plus 2 bytes payload length, plus
		 * payload, plus padding
		 */
		buffer = OPENSSL_malloc(1 + 2 + payload + padding);
		bp = buffer;

		/* Enter response type, length and copy payload */
		*bp++ = TLS1_HB_RESPONSE;
		s2n(payload, bp);
		memcpy(bp, pl, payload);
		bp += payload;
		/* Random padding */
		RAND_pseudo_bytes(bp, padding);

		r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, 3 + payload + padding);

		if (r >= 0 && s->msg_callback)
			s->msg_callback(1, s->version, TLS1_RT_HEARTBEAT,
				buffer, 3 + payload + padding,
				s, s->msg_callback_arg);

		OPENSSL_free(buffer);

		if (r < 0)
			return r;
		}
	else if (hbtype == TLS1_HB_RESPONSE)
		{
		unsigned int seq;

		/* We only send sequence numbers (2 bytes unsigned int),
		 * and 16 random bytes, so we just try to read the
		 * sequence number */
		n2s(pl, seq);

		if (payload == 18 && seq == s->tlsext_hb_seq)
			{
			dtls1_stop_timer(s);
			s->tlsext_hb_seq++;
			s->tlsext_hb_pending = 0;
			}
		}

	return 0;
	}
{% endhighlight %}

### 参考文献

- [The Heartbleed Bug](http://heartbleed.com/)
- [RFC6520: Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS) Heartbeat Extension](https://tools.ietf.org/html/rfc6520)
- [A technical view of the OpenSSL ‘Heartbleed’ vulnerability](https://www.ibm.com/developerworks/community/files/basic/anonymous/api/library/38218957-7195-4fe9-812a-10b7869e4a87/document/ab12b05b-9f07-4146-8514-18e22bd5408c/media) (这篇写的很好)
- [CVE-2014-0160 Heartbleed分析报告 ](http://www.freebuf.com/articles/web/31700.html)
- [一洞观全球：看各国网络战防御能力](http://blog.knownsec.com/2014/12/look_up_the_gloable_world_defence_ability_with_one_bug/)
- [ZoomEye 心脏出血 统计报告](https://www.zoomeye.org/lab/heartbleed)
- [“心脏出血”漏洞一周年全球普查](https://www.zoomeye.org/lab/heartbleed/2015?port=&code=&p=1)
- [SSL/TLS的Heartbeat 扩展](http://blog.csdn.net/liuxb1223/article/details/35276179)
- [OpenSSL Heartbleed “心脏滴血”漏洞简单攻击示例](http://www.lijiejie.com/openssl-heartbleed-attack/)
- 安思华，易平，王春新，李朝峰 . OpenSSLHeartbleed漏洞攻击原理及防范方法研究 . 通信技术，第47卷，第7期
- 杨勇，邹雷 . OpenSSLHeartbleed漏洞研究及启示 . 信息安全与通信保密，2014.05