---
category: murmur
title: Pwn探索笔记
---

## Pwn探索笔记

### 前言

我最早是跟着[海枫老师的专栏](http://blog.csdn.net/column/details/buffer-overflow.html)入门。后来在调试的过程中，遇到各种各样“奇怪”的错误，进而导致无法达到预期效果。计算机领域没有什么不可解释的问题，出现状况只能说明我的水平还有待提高。遗憾的是，我没有很好地把所有错误记录下来。痛定思痛，我打算在此开辟一方天地，记录探索历程。

未读过的文章链接放在【未读】部分，已研究的文章的链接在文中随研究历程出现。随着探索的进行，我会把链接慢慢地从【未读】部分纳入探索范围。

本文包括但不限于缓冲区溢出等常用Pwn技术。

### Linux 各种保护机制浅析

参考：[checksec及其包含的保护机制](http://yunnigu.dropsec.xyz/2016/10/08/checksec%E5%8F%8A%E5%85%B6%E5%8C%85%E5%90%AB%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/)。

**N^X**

```
# by default it is on
# set off
gcc -o test test.c -z execstack
```

**PIE**

```
# by default it is off
# set on
gcc -o test test.c -pie
```

**ASLR**

```
# see whether on
cat /proc/sys/kernel/randomize_va_space
## 1 = base_addr_of_mmap/stack/vdso randomized
## 2 = 1 + randomization of heap
# set off
echo 0 > /proc/sys/kernel/randomize_va_space
```

**Canary**

```
# set off
gcc -o test test.c -fno-stack-protector
# set on for functions which hold char arrays
gcc -o test test.c -fstack-protector
# set on for all functions
gcc -o test test.c -fstack-protector-all
```

**Fortify**

**RELRO**


### ret2plt,ret2libc 传参问题

遇到一个 ret2plt 调用 system 的情况，理论上很简单，但一直打不开 Shell。后来写了一个正常的调用 system 函数打开 Shell 的程序，进入 GDB 单步调试观察栈的变化情况，终于发现了自己一直以来的一个错误。

错误的 Shellcode 如下：

```
'A' * 272 + system_addr + sh_str_addr
```

正确的 Shellcode 如下：

```
'A' * 272 + system_addr + ret_addr + sh_str_addr
```

`sh_str_addr`是给 system 提供的参数。注意我们是通过覆盖原函数返回地址的方式来劫持控制流的，与正常的直接`call system`是不同的。所以我们要先提供一个`ret_addr`放在栈上，作为 system 函数返回后的地址，再把它需要的参数放在栈上。一般来说`ret_addr`放什么都可以，如果希望程序能够正常结束，还是放一个类似 exit 的函数的地址比较好（如果能够找到的话）。

### Shell 打开后直接退出（待解决）

再一次遇到了以前碰到过的未解问题，即命令行手动拼接 Shellcode 成功打开 Shell，但是 Shell 会在打开后立即退出，而如果使用 zio 去输入 Shellcode，则能成功打开 Shell，效果图分别如下：

通过重定向手动输入 Shellcode，GDB 中显示成功打开了 Shell，但 Shell 直接退出：

![]({{ site.url }}/resources/pictures/17_09_08_gdb_question0.png)

通过 zio：

![]({{ site.url }}/resources/pictures/17_09_08_gdb_question1.png)

之前[我的另一篇文章](http://aptx4869.me/ctf/2017/05/06/PwnChallenge-0.html)里记录了类似的问题，但是也没有解决。后来看网上有朋友遇到了另一个 Shell 打不开的问题，[他的文章](http://o0xmuhe.me/2016/11/10/linux-%E4%B8%8B%E8%B5%B7shell%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%88%86%E6%9E%90/)详细记录了问题及解决方法，与我碰到的不一样，但是其中用到的思路和方法值得借鉴。

### 我怎么知道远程环境的函数地址？（待解决）

如果远程环境没有`PIE`的干扰，那么我们在自己环境中通过逆向二进制程序得到的函数地址，或者`plt`表中的地址都可以直接放在 Shellcode 中，在远程环境同样适用。问题在于

- 如果我需要的是`libc`库里的函数地址，而且对方没有开`ASLR`，那么我的本地系统环境和对方的系统环境存在差异会不会导致我在本地测试的相关地址在远程环境不适用？如何解决这一问题？假如我知道了对方的`libc`库版本，是否可以下载对应版本的库并从中获得正确的函数地址？怎样获取？
- 对于经典的栈溢出（也没有`ASLR`），本地环境的栈地址我可以获得，所以可以知道控制流应该被劫持到哪里触发 Shellcode。然而远程环境的栈地址我该如何获得？

### 博客

高手的博客总结了许多精华，多学习。

- [o0xmuhe](http://o0xmuhe.me)
- [k0shl](http://whereisk0shl.top/)
- [gbmaster](https://gbmaster.wordpress.com/)
- [Yun](http://yunnigu.dropsec.xyz/)
- [程序人生](http://www.programlife.net)

### 未读

- [CTF Pwn Notes](http://aptx4869.me/ctf/2017/03/31/learnPwn.html)
- [现代Linux操作系统的栈溢出（上）](http://www.freebuf.com/articles/system/24177.html)
- 海枫专栏 [深入浅出缓冲区溢出攻击](http://blog.csdn.net/column/details/buffer-overflow.html)
- [手把手教你栈溢出从入门到放弃（上）](https://zhuanlan.zhihu.com/p/25816426)
- [手把手教你栈溢出从入门到放弃（下）](https://zhuanlan.zhihu.com/p/25892385)
- [【技术分享】远程漏洞利用：无需借助套接字的Shellcode](http://bobao.360.cn/learning/detail/3402.html)
- [【技术分享】从一个CTF题目学习Python沙箱逃逸](http://bobao.360.cn/learning/detail/3542.html)
- [【CTF攻略】ZCTF Pwn500 GoodLuck详解](http://bobao.360.cn/ctf/detail/187.html)
- [【系列分享】Linux 内核漏洞利用教程（一）：环境配置](http://bobao.360.cn/learning/detail/3700.html)
- [【系列分享】Linux 内核漏洞利用教程（二）：两个Demo](http://bobao.360.cn/learning/detail/3702.html)
- [【系列分享】Linux 内核漏洞利用教程（三）：实践 CSAW CTF 题目](http://bobao.360.cn/learning/detail/3706.html)
- [【CTF攻略】格式化字符串blind pwn详细教程](http://bobao.360.cn/ctf/detail/189.html)
- [【技术分享】格式化字符串漏洞利用小结（二）](http://www.360zhijia.com/360anquanke/188070.html)
- [Exploiting Format String Vulnerabilities](https://crypto.stanford.edu/cs155/papers/formatstring-1.2.pdf)
- [Smashing The Stack For Fun And Profit](http://insecure.org/stf/smashstack.html)
- [x86 Exploitation 101: “House of Spirit” – Friendly stack overflow](https://gbmaster.wordpress.com/2015/07/21/x86-exploitation-101-house-of-spirit-friendly-stack-overflow/)
- [Exploiting the heap](http://www.win.tue.nl/~aeb/linux/hh/hh-11.html)
- [Linux堆内存管理深入分析(上半部)](http://jaq.alibaba.com/community/art/show?spm=a313e.7916646.24000001.45.nv3onP&articleid=315)
- [一步一步学ROP之linux_x86篇](http://jaq.alibaba.com/community/art/show?spm=a313e.7916646.24000001.29.qktl5B&articleid=403)
- [一步一步学ROP之linux_x64篇](http://jaq.alibaba.com/community/art/show?spm=a313e.7916646.24000001.2.qktl5B&articleid=473)
- [Linux堆溢出漏洞利用之unlink](http://jaq.alibaba.com/community/art/show?spm=a313e.7916646.24000001.37.qktl5B&articleid=360)
- [Linux (x86) Exploit Development Series](https://sploitfun.wordpress.com/2015/06/26/linux-x86-exploit-development-tutorial-series/)
- [Syscalls used by malloc](https://sploitfun.wordpress.com/2015/02/11/syscalls-used-by-malloc/?spm=a313e.7916648.0.0.NP952U)
- [Understanding glibc malloc](https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/)
- [Github: shellphish/how2heap](https://github.com/shellphish/how2heap)
- [【技术分享】堆之House of Spirit](http://bobao.360.cn/learning/detail/3417.html)
- [【技术分享】通过静态分析检测二进制代码中的Use-After-Free漏洞 ](http://bobao.360.cn/learning/detail/3308.html)
- [【技术分享】溢出利用FILE结构体](http://bobao.360.cn/learning/detail/3219.html)
- [【技术分享】unsorted bin attack分析](http://bobao.360.cn/learning/detail/3296.html)
- [实战HeapSpray之CVE2012-1889 Exploit编写（一）](http://www.programlife.net/heapspray-cve2012-1889-exploit-1.html)
- [程序人生/缓冲区溢出](http://www.programlife.net/category/windev/exploit)
- [【技术分享】借助DynELF实现无libc的漏洞利用小结](http://bobao.360.cn/learning/detail/3298.html)
- [Heap Spray原理浅析](http://blog.csdn.net/magictong/article/details/7391397)
- [【技术分享】现代栈溢出利用技术基础：ROP](http://bobao.360.cn/learning/detail/3694.html)
- [pwn学习之dl_resolve学习篇](http://blog.csdn.net/joez_blog/article/details/51268006)